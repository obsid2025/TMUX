#!/bin/bash
# tp - Tmux Projects
# Fiecare folder/proiect = server tmux izolat
# Cu auto-save È™i auto-restore

# CRITICAL: DezactiveazÄƒ tmux-continuum auto-restore pentru servere tp
# È˜tergem variabila care activeazÄƒ auto-restore
unset TMUX_CONTINUUM_RESTORE

# Folosim path-ul complet hash-uit pentru a evita coliziunile Ã®ntre directoare cu acelaÈ™i nume
PROJECT_DISPLAY_NAME=$(basename "$PWD")
PROJECT_HASH=$(echo "$PWD" | md5sum | cut -d' ' -f1 | cut -c1-8)
PROJECT_NAME="${PROJECT_DISPLAY_NAME}_${PROJECT_HASH}"
SAVE_DIR="$HOME/.tmux/project-saves"

mkdir -p "$SAVE_DIR"

# ISTORIC BASH IZOLAT PER PANOU
# HISTFILE se seteazÄƒ automat per panou Ã®n .bashrc
# Export doar PROJECT_NAME pentru ca panourile noi sÄƒ È™tie Ã®n ce proiect sunt
export PROJECT_NAME

# FuncÈ›ie pentru auto-restore dacÄƒ serverul nu ruleazÄƒ
auto_restore() {
    LOG_FILE="$SAVE_DIR/$PROJECT_NAME.restore.log"
    echo "=== RESTORE START: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$LOG_FILE"

    if ! tmux -L "$PROJECT_NAME" has-session 2>/dev/null; then
        RESURRECT_DIR="$SAVE_DIR/resurrect"
        RESTORED=false
        echo "No active session found, starting restore..." >> "$LOG_FILE"

        # DEZACTIVAT tmux-resurrect - restaureazÄƒ global din toate proiectele
        # Folosim doar restaurarea simplÄƒ per-proiect
        # if [ -f "$HOME/.tmux/plugins/tmux-resurrect/scripts/restore.sh" ]; then
        #     ...
        # fi

        # Fallback: restaurare simplÄƒ dacÄƒ tmux-resurrect nu a mers
        if [ "$RESTORED" = false ] && [ -f "$SAVE_DIR/$PROJECT_NAME.sessions" ] && [ -s "$SAVE_DIR/$PROJECT_NAME.sessions" ]; then
            echo "Auto-restaurare proiect '$PROJECT_DISPLAY_NAME'..."
            echo "Found save files, restoring..." >> "$LOG_FILE"
            echo "Sessions file: $(cat "$SAVE_DIR/$PROJECT_NAME.sessions" | wc -l) sessions" >> "$LOG_FILE"
            echo "Windows file: $(cat "$SAVE_DIR/$PROJECT_NAME.windows" | wc -l) windows" >> "$LOG_FILE"
            echo "Panes file: $(cat "$SAVE_DIR/$PROJECT_NAME.panes" | wc -l) panes" >> "$LOG_FILE"

            # RestaureazÄƒ sesiunile È™i ferestrele cu layout
            if [ -f "$SAVE_DIR/$PROJECT_NAME.windows" ]; then
                echo "Restoring windows..." >> "$LOG_FILE"
                while IFS=: read session window_idx window_name layout; do
                    [ -z "$session" ] && continue
                    echo "  Window: $session:$window_idx ($window_name)" >> "$LOG_FILE"

                    # CreeazÄƒ sesiunea dacÄƒ nu existÄƒ
                    if ! tmux -L "$PROJECT_NAME" has-session -t "$session" 2>/dev/null; then
                        tmux -L "$PROJECT_NAME" new-session -d -s "$session" -c "$PWD" 2>/dev/null
                        # Prima fereastrÄƒ se creeazÄƒ automat, o redenumim
                        tmux -L "$PROJECT_NAME" rename-window -t "${session}:${window_idx}" "$window_name" 2>/dev/null
                    else
                        # AdaugÄƒ ferestre noi
                        tmux -L "$PROJECT_NAME" new-window -t "$session" -n "$window_name" -c "$PWD" 2>/dev/null
                    fi

                    # NumÄƒrÄƒ cÃ¢te panourile trebuie sÄƒ aibÄƒ aceastÄƒ fereastrÄƒ
                    pane_count=$(grep -c "^${session}:${window_idx}:" "$SAVE_DIR/$PROJECT_NAME.panes" 2>/dev/null || echo "1")
                    # CurÄƒÈ›Äƒ whitespace
                    pane_count=$(echo "$pane_count" | tr -d '\n\r ' | grep -o '[0-9]*' || echo "1")
                    [ -z "$pane_count" ] && pane_count=1
                    echo "    Pane count for this window: $pane_count" >> "$LOG_FILE"

                    # CreeazÄƒ split-urile necesare (pane_count - 1, cÄƒci primul panou existÄƒ deja)
                    if [ "$pane_count" -gt 1 ] 2>/dev/null; then
                        for ((i=2; i<=$pane_count; i++)); do
                            tmux -L "$PROJECT_NAME" split-window -t "${session}:${window_idx}" -c "$PWD" 2>/dev/null
                        done
                    fi

                    # AplicÄƒ layout-ul DUPÄ‚ ce am creat toate panourile
                    [ -n "$layout" ] && sleep 0.1 && tmux -L "$PROJECT_NAME" select-layout -t "${session}:${window_idx}" "$layout" 2>/dev/null
                done < "$SAVE_DIR/$PROJECT_NAME.windows"
            fi

            # RestaureazÄƒ path-urile, scroll-back, comenzile È™i titlurile panourilor
            if [ -f "$SAVE_DIR/$PROJECT_NAME.panes" ]; then
                sleep 0.3
                echo "Restoring pane details..." >> "$LOG_FILE"

                # CreeazÄƒ directorul pentru HISTFILE hints (fiÈ™iere temporare)
                HISTFILE_HINT_DIR="/tmp/tmux-histfile-hints/$PROJECT_NAME"
                mkdir -p "$HISTFILE_HINT_DIR"

                while IFS=: read -r session window_idx pane_idx pane_path pane_cmd pane_title; do
                    [ -z "$session" ] || [ -z "$pane_path" ] && continue

                    PANE_TARGET="${session}:${window_idx}.${pane_idx}"
                    echo "  Pane: $PANE_TARGET | Path: $pane_path | Cmd: $pane_cmd | Title: $pane_title" >> "$LOG_FILE"

                    # SOLUÈšIA: Scrie HISTFILE path ÃŽNAINTE de respawn-pane
                    # .bashrc va citi din acest fiÈ™ier Ã®n loc sÄƒ Ã®ntrebe tmux pentru titlu
                    if [ -n "$pane_title" ]; then
                        # SanitizeazÄƒ pentru nume de fiÈ™ier
                        SESSION_SAFE=$(echo "$session" | tr ' /' '__' | tr -cd '[:alnum:]_-')
                        TITLE_SAFE=$(echo "$pane_title" | tr ' /' '__' | tr -cd '[:alnum:]_-')
                        HISTFILE_PATH="$SAVE_DIR/$PROJECT_NAME/history/${SESSION_SAFE}-${TITLE_SAFE}.bash"

                        # Scrie Ã®n fiÈ™ierul hint (folosind identificator unic per panou)
                        HINT_FILE="$HISTFILE_HINT_DIR/${session}_${window_idx}_${pane_idx}"
                        echo "$HISTFILE_PATH" > "$HINT_FILE"
                        echo "    HISTFILE hint: $HINT_FILE -> $HISTFILE_PATH" >> "$LOG_FILE"
                    fi

                    # RestaureazÄƒ directorul INVIZIBIL prin respawn-pane
                    # Acest lucru recreazÄƒ shell-ul Ã®n path-ul corect FÄ‚RÄ‚ sÄƒ execute cd vizibil
                    tmux -L "$PROJECT_NAME" respawn-pane -k -t "$PANE_TARGET" -c "$pane_path" 2>/dev/null
                    sleep 0.2

                    # SeteazÄƒ titlul IMEDIAT dupÄƒ respawn (pentru afiÈ™are Ã®n tmux)
                    if [ -n "$pane_title" ]; then
                        tmux -L "$PROJECT_NAME" select-pane -t "$PANE_TARGET" -T "$pane_title" 2>/dev/null
                    fi

                    # AÈ™teaptÄƒ ca shell-ul nou sÄƒ porneascÄƒ
                    sleep 0.3

                    # RESTAUREAZÄ‚ SCROLL-BACK (conÈ›inutul vizual al panoului CU CULORI)
                    SCROLLBACK_FILE="$SAVE_DIR/scrollback/$PROJECT_NAME/${session}_${window_idx}_${pane_idx}.txt"
                    if [ -f "$SCROLLBACK_FILE" ] && [ -s "$SCROLLBACK_FILE" ]; then
                        # AfiÈ™eazÄƒ scroll-back-ul salvat cu culori (fÄƒrÄƒ clear pentru a evita spaÈ›iu gol)
                        tmux -L "$PROJECT_NAME" send-keys -t "$PANE_TARGET" "cat '$SCROLLBACK_FILE'" C-m 2>/dev/null
                        sleep 0.2
                    fi

                    # ReporneÈ™te comanda dacÄƒ nu e doar shell
                    if [ -n "$pane_cmd" ] && [ "$pane_cmd" != "shell" ]; then
                        sleep 0.1
                        tmux -L "$PROJECT_NAME" send-keys -t "$PANE_TARGET" "$pane_cmd" C-m 2>/dev/null
                    fi
                done < "$SAVE_DIR/$PROJECT_NAME.panes"

                # CurÄƒÈ›Äƒ directorul hint dupÄƒ ce toate panourile au pornit
                sleep 1
                rm -rf "$HISTFILE_HINT_DIR" 2>/dev/null
            fi

            echo "Restaurat!"
            echo "=== RESTORE COMPLETED: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$LOG_FILE"
        fi
    else
        echo "Session already exists, skipping restore" >> "$LOG_FILE"
    fi
}

# FuncÈ›ie pentru salvare
do_save() {
    if tmux -L "$PROJECT_NAME" has-session 2>/dev/null; then
        # SalveazÄƒ sesiuni È™i ferestre
        tmux -L "$PROJECT_NAME" list-sessions -F "#{session_name}" > "$SAVE_DIR/$PROJECT_NAME.sessions"
        tmux -L "$PROJECT_NAME" list-windows -a -F "#{session_name}:#{window_index}:#{window_name}:#{window_layout}" > "$SAVE_DIR/$PROJECT_NAME.windows"

        # SalveazÄƒ panourile cu ATOMIC WRITE (nu suprascrie dacÄƒ salvarea eÈ™ueazÄƒ)
        TEMP_PANES="$SAVE_DIR/$PROJECT_NAME.panes.tmp"
        > "$TEMP_PANES"

        # CreeazÄƒ director pentru scroll-back dacÄƒ nu existÄƒ
        mkdir -p "$SAVE_DIR/scrollback/$PROJECT_NAME"

        tmux -L "$PROJECT_NAME" list-panes -a -F "#{session_name}:#{window_index}:#{pane_index}:#{pane_current_path}:#{pane_pid}:#{pane_title}" | while IFS=: read -r session window_idx pane_idx pane_path pane_pid pane_title; do
            [ -z "$session" ] && continue
            full_cmd=$(ps --ppid "$pane_pid" -o args= 2>/dev/null | head -1)
            [ -z "$full_cmd" ] && full_cmd=$(pgrep -P "$pane_pid" -a 2>/dev/null | head -1 | cut -d' ' -f2-)
            [ -z "$full_cmd" ] && full_cmd="shell"
            full_cmd=$(echo "$full_cmd" | tr -cd '[:print:]')
            echo "${session}:${window_idx}:${pane_idx}:${pane_path}:${full_cmd}:${pane_title}" >> "$TEMP_PANES"

            # SALVARE SCROLL-BACK (tot conÈ›inutul vizibil din terminal)
            SCROLLBACK_FILE="$SAVE_DIR/scrollback/$PROJECT_NAME/${session}_${window_idx}_${pane_idx}.txt"
            tmux -L "$PROJECT_NAME" capture-pane -p -e -S - -t "${session}:${window_idx}.${pane_idx}" > "$SCROLLBACK_FILE" 2>/dev/null || true
        done

        # MutÄƒ fiÈ™ierul temporar peste cel vechi DOAR dacÄƒ salvarea a reuÈ™it (fiÈ™ier nu e gol)
        if [ -s "$TEMP_PANES" ]; then
            mv "$TEMP_PANES" "$SAVE_DIR/$PROJECT_NAME.panes"
        else
            # DacÄƒ salvarea a eÈ™uat, pÄƒstreazÄƒ fiÈ™ierul vechi È™i È™terge temporarul
            rm -f "$TEMP_PANES"
        fi
    fi
    # NU È™tergem salvÄƒrile cÃ¢nd sesiunea nu existÄƒ - le pÄƒstrÄƒm pentru restore!
}

# FuncÈ›ie pentru attach/create sesiune
attach_or_create() {
    local SESSION_NAME="${1:-main}"
    auto_restore
    if tmux -L "$PROJECT_NAME" has-session -t "$SESSION_NAME" 2>/dev/null; then
        do_save
        tmux -L "$PROJECT_NAME" attach -t "$SESSION_NAME"
        do_save
    else
        tmux -L "$PROJECT_NAME" new-session -s "$SESSION_NAME" -c "$PWD"
        do_save
    fi
}

case "$1" in
    "")
        auto_restore
        if tmux -L "$PROJECT_NAME" has-session 2>/dev/null; then
            do_save
            tmux -L "$PROJECT_NAME" attach
            do_save
        else
            tmux -L "$PROJECT_NAME" new-session -s main -c "$PWD"
            do_save
        fi
        ;;
    ls)
        auto_restore
        if tmux -L "$PROJECT_NAME" ls 2>/dev/null; then
            # ExistÄƒ sesiuni - totul ok
            true
        else
            echo "Nicio sesiune Ã®n proiectul '$PROJECT_DISPLAY_NAME'"
            # CurÄƒÈ›Äƒ salvÄƒrile dacÄƒ nu existÄƒ sesiuni
            do_save
        fi
        ;;
    ls-all)
        echo "Proiecte active:"
        for sock in /tmp/tmux-$(id -u)/*; do
            [ -S "$sock" ] || continue
            name=$(basename "$sock")
            # VerificÄƒ dacÄƒ serverul chiar ruleazÄƒ (nu doar socket zombie)
            if tmux -L "$name" ls 2>/dev/null | grep -q .; then
                echo "  ðŸ“ $name"
                tmux -L "$name" ls 2>/dev/null | sed 's/^/      /'
            else
                # CurÄƒÈ›Äƒ socket-ul zombie
                rm -f "$sock" 2>/dev/null
            fi
        done
        ;;
    new)
        auto_restore
        tmux -L "$PROJECT_NAME" new-window -n "$2" -c "$PWD"
        do_save
        ;;
    rename)
        tmux -L "$PROJECT_NAME" rename-window "$2"
        do_save
        echo "FereastrÄƒ redenumitÄƒ: $2"
        ;;
    rename-session)
        tmux -L "$PROJECT_NAME" rename-session -t "$2" "$3"
        do_save
        echo "Sesiune '$2' redenumitÄƒ Ã®n '$3'"
        ;;
    create)
        auto_restore
        SESSION_NAME="${2:-main}"
        tmux -L "$PROJECT_NAME" new-session -d -s "$SESSION_NAME" -c "$PWD"
        do_save
        echo "Sesiune '$SESSION_NAME' creatÄƒ Ã®n proiectul '$PROJECT_DISPLAY_NAME'"
        ;;
    kill)
        tmux -L "$PROJECT_NAME" kill-server 2>/dev/null
        # È˜terge socket-ul zombie dacÄƒ a rÄƒmas
        rm -f /tmp/tmux-$(id -u)/"$PROJECT_NAME" 2>/dev/null
        echo "Proiect '$PROJECT_DISPLAY_NAME' oprit (salvarea rÄƒmÃ¢ne pentru restore)"
        echo "FoloseÈ™te 'tp purge' pentru È™tergere permanentÄƒ"
        ;;
    purge)
        tmux -L "$PROJECT_NAME" kill-server 2>/dev/null
        # È˜terge socket-ul zombie
        rm -f /tmp/tmux-$(id -u)/"$PROJECT_NAME" 2>/dev/null
        # È˜terge TOATE salvÄƒrile (nu se va mai restaura)
        rm -f "$SAVE_DIR/$PROJECT_NAME".* 2>/dev/null
        rm -rf "$SAVE_DIR/resurrect" 2>/dev/null
        echo "Proiect '$PROJECT_DISPLAY_NAME' È™ters complet (fÄƒrÄƒ restaurare)"
        ;;
    kill-session)
        if [ -z "$2" ]; then
            echo "Eroare: Trebuie sÄƒ specifici numele sesiunii"
            echo "Folosire: tp kill-session NUME_SESIUNE"
            exit 1
        fi
        tmux -L "$PROJECT_NAME" kill-session -t "$2" 2>/dev/null
        do_save
        echo "Sesiune '$2' È™tearsÄƒ"
        ;;
    send)
        shift
        tmux -L "$PROJECT_NAME" send-keys "$@"
        ;;
    split)
        # CreeazÄƒ split orizontal cu path specificat
        # DetecteazÄƒ socket-ul tmux curent dacÄƒ suntem Ã®ntr-o sesiune
        if [ -n "$TMUX" ]; then
            CURRENT_SOCKET=$(echo "$TMUX" | cut -d',' -f1)
            CURRENT_PROJECT=$(basename "$CURRENT_SOCKET")
        else
            CURRENT_PROJECT="$PROJECT_NAME"
        fi
        SPLIT_PATH="${2:-$(pwd)}"
        tmux -L "$CURRENT_PROJECT" split-window -v -c "$SPLIT_PATH"
        echo "Split creat Ã®n: $SPLIT_PATH"
        ;;
    vsplit)
        # CreeazÄƒ split vertical cu path specificat
        if [ -n "$TMUX" ]; then
            CURRENT_SOCKET=$(echo "$TMUX" | cut -d',' -f1)
            CURRENT_PROJECT=$(basename "$CURRENT_SOCKET")
        else
            CURRENT_PROJECT="$PROJECT_NAME"
        fi
        SPLIT_PATH="${2:-$(pwd)}"
        tmux -L "$CURRENT_PROJECT" split-window -h -c "$SPLIT_PATH"
        echo "VSplit creat Ã®n: $SPLIT_PATH"
        ;;
    pane)
        # CreeazÄƒ panou nou cu path È™i titlu opÈ›ional
        if [ -n "$TMUX" ]; then
            CURRENT_SOCKET=$(echo "$TMUX" | cut -d',' -f1)
            CURRENT_PROJECT=$(basename "$CURRENT_SOCKET")
        else
            CURRENT_PROJECT="$PROJECT_NAME"
        fi
        PANE_PATH="${2:-$(pwd)}"
        tmux -L "$CURRENT_PROJECT" split-window -v -c "$PANE_PATH"
        if [ -n "$3" ]; then
            tmux -L "$CURRENT_PROJECT" select-pane -T "$3"
        fi
        echo "Panou creat Ã®n: $PANE_PATH"
        ;;
    cd)
        # SchimbÄƒ directorul Ã®n panoul curent
        if [ -n "$TMUX" ]; then
            CURRENT_SOCKET=$(echo "$TMUX" | cut -d',' -f1)
            CURRENT_PROJECT=$(basename "$CURRENT_SOCKET")
        else
            CURRENT_PROJECT="$PROJECT_NAME"
        fi
        if [ -z "$2" ]; then
            echo "Folosire: tp cd /path/to/dir"
            exit 1
        fi
        tmux -L "$CURRENT_PROJECT" send-keys "cd '$2'" C-m
        echo "Director schimbat Ã®n: $2"
        ;;
    save)
        do_save
        echo "Proiect '$PROJECT_DISPLAY_NAME' salvat"
        ;;
    restore)
        auto_restore
        tmux -L "$PROJECT_NAME" ls 2>/dev/null || echo "Nimic de restaurat"
        ;;
    help|--help|-h)
        echo "tp - Tmux Projects (izolate per folder, cu auto-save/restore)"
        echo ""
        echo "Folosire:"
        echo "  tp                  Attach la proiect (auto-restore)"
        echo "  tp SESIUNE          Attach/creazÄƒ sesiune cu nume"
        echo "  tp create NUME      CreazÄƒ sesiune (fÄƒrÄƒ attach)"
        echo ""
        echo "Panouri cu path explicit (IMPORTANT pentru workflow corect):"
        echo "  tp split [PATH]     Split orizontal Ã®n PATH (default: pwd)"
        echo "  tp vsplit [PATH]    Split vertical Ã®n PATH (default: pwd)"
        echo "  tp pane PATH [TITLU]  Panou nou cu path È™i titlu opÈ›ional"
        echo "  tp cd PATH          SchimbÄƒ directorul panoului curent"
        echo "  tp ls               Lista sesiuni (auto-restore)"
        echo "  tp ls-all           Lista TOATE proiectele"
        echo "  tp new WINDOW       CreazÄƒ fereastrÄƒ nouÄƒ"
        echo "  tp rename NUME      RedenumeÈ™te fereastra"
        echo "  tp rename-session OLD NEW  RedenumeÈ™te sesiunea"
        echo "  tp save             SalveazÄƒ manual"
        echo "  tp kill             OpreÈ™te proiectul (pÄƒstreazÄƒ salvÄƒrile)"
        echo "  tp purge            È˜terge proiectul COMPLET (fÄƒrÄƒ restore)"
        echo "  tp kill-session X   È˜terge sesiunea X"
        echo ""
        echo "Proiect curent: $PROJECT_DISPLAY_NAME ($PWD)"
        echo "Auto-save: la fiecare operaÈ›iune"
        echo "Auto-restore: cÃ¢nd serverul nu ruleazÄƒ"
        ;;
    *)
        attach_or_create "$1"
        ;;
esac
